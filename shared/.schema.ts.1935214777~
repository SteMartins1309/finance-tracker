// IMPORTS

import {
  pgTable,
  text,
  serial,
  integer,
  boolean,    // conferir se foi usado
  decimal,
  timestamp,
  pgEnum,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";


// ENUMS

//--------------------------------------------------------------------------------
// Para TODAS as despesas, rotineiras e ocasionais

// paymentMethodEnum: método de pagamento
export const paymentMethodEnum = pgEnum("payment_method", [
  "pix",
  "debit-card",
  "credit-card",  
  "cash",
  "bank-transfer",
]);

// expenseTypeEnum: tipo de despesa (rotina ou ocasional)
export const expenseTypeEnum = pgEnum("expense_type", [
  "routine",
  "occasional",
]);

// routineCategoryEnum: categoria de despesa rotineira
export const routineCategoryEnum = pgEnum("routine_category", [
  "fixed",  
  "supermarket", 
  "food",  
  "services", 
  "leisure", 
  "personal-care", 
  "shopping",  
  "transportation", 
  "health",
  "family",  
  "charity",  
]);
//--------------------------------------------------------------------------------

// occasionalGroupStatusEnum: status do grupo de despesas ocasionais  (categoria 'occasional')
export const occasionalGroupStatusEnum = pgEnum("occasional_group_status", [
  "open",
  "closed",
]);

// frequencyTypeEnum: frequência de pagamento  (subcategoria 'fixed')
export const frequencyTypeEnum = pgEnum("frequency_type", [
  "weekly", 
  "monthly", 
  "semi-annually", 
  "annually"
]);

// occasionTypeEnum: tipo de ocasião  (subcategorias 'food' e 'shopping')
export const occasionTypeEnum = pgEnum("occasion_type", [
  "normal", 
  "special"
]);

// purchaseTypeEnum: tipo de compra  (subcategorias 'food' e 'shopping')
export const purchaseTypeEnum = pgEnum("purchase_type", [
  "in-person",
  "online",
]);

// transportModeEnum: modo de transporte  (subcategoria 'transportation')
export const transportModeEnum = pgEnum("transport_mode", [
  "car",
  "uber",
  "public-transport",
  "walking",
  "bicycle",
]);



// TABELAS

// users: tabela de usuários
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

// occasionalGroups: tabela de grupos de despesas ocasionais  (categoria 'occasional')
export const occasionalGroups = pgTable("occasional_groups", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  status: occasionalGroupStatusEnum("status").notNull().default("open"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// fixedExpenseTypes: tabela de tipos de despesas fixas  (subcategoria 'fixed')
export const fixedExpenseTypes = pgTable("fixed_expense_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// supermarkets: tabela de supermercados  (subcategoria 'supermarket')
export const supermarkets = pgTable("supermarkets", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// restaurants: tabela de restaurantes  (subcategoria 'food')
export const restaurants = pgTable("restaurants", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// serviceTypes: tabela de tipos de serviços  (subcategoria 'services')
export const serviceTypes = pgTable("service_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// leisureTypes: tabela de tipos de lazer  (subcategoria 'leisure')
export const leisureTypes = pgTable("leisure_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// personalCareTypes: tabela de tipos de cuidados pessoais  (subcategoria 'personal-care')
export const personalCareTypes = pgTable("personal_care_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// shops: tabela de lojas  (subcategoria 'shopping')
export const shops = pgTable("shops", { 
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// places: tabela de lugares  (subcategoria 'transportation')
export const places = pgTable("places", { 
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// healthTypes: tabela de tipos de saúde  (subcategoria 'health')
export const healthTypes = pgTable("health_types", { 
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// familyMembers: tabela de membros da família  (subcategoria 'family')
export const familyMembers = pgTable("family_members", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// charityTypes: tabela de tipos de caridade  (subcategoria 'charity')
export const charityTypes = pgTable("charity_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});



// EXPENSES: tabela de despesas

export const expenses = pgTable("expenses", {

  // Cada campo é uma chave estrangeira (foreign keys) que referencia uma das tabelas de categorias específicas

  
  // Geral para todas as despesas
  id: serial("id").primaryKey(),  // ID da despesa
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),  // Valor da despesa
  purchaseDate: timestamp("purchase_date").notNull(),  // Data da compra
  paymentMethod: paymentMethodEnum("payment_method").notNull(),  // Método de pagamento
  expenseType: expenseTypeEnum("expense_type").notNull(),  // Tipo de despesa (rotina ou ocasional)
  routineCategory: routineCategoryEnum("routine_category"),  // Categoria de despesa rotineira (se for rotina)
  occasionalGroupId: integer("occasional_group_id"),  // ID do grupo de despesas ocasionais (se for ocasional)

  
  // Para as subcategorias de despesas rotineiras

  // Para a subcategoria 'fixed'
  fixedExpenseTypeId: integer("fixed_expense_type_id"),  // ID do tipo de despesa fixa
  frequency: frequencyTypeEnum("frequency"),  // Frequência de pagamento
  
  // Para a subcategoria 'supermarket'
  supermarketId: integer("supermarket_id"),  // ID do supermercado
  
  // Para a subcategoria 'food'
  restaurantId: integer("restaurant_id"),  // ID do restaurante
  occasionType: occasionTypeEnum("occasion_type").default("normal"),  // Tipo de ocasião
  specialOccasionDescription: text("special_occasion_description"),  // Descrição da ocasião especial
  foodPurchaseType: purchaseTypeEnum("food_purchase_type"),  // Modo de compra
  restaurantName: text("store_name"),  // Nome da loja

  // Para a subcategoria 'services'
  serviceTypeId: integer("service_type_id"),
  serviceDescription: text("service_description"),

  // Para a subcategoria 'leisure'
  leisureTypeId: integer("leisure_type_id"),
  leisureDescription: text("leisure_description"),

  // Para a subcategoria 'personal-care'
  personalCareTypeId: integer("personal_care_type_id"),
  personalCareDescription: text("personal_care_description"),

  // Para a subcategoria 'shopping'
  shopId: integer("shop_id"),
  shoppingPurchaseType: purchaseTypeEnum("shopping_purchase_type"), 
  shoppingOccasionType: occasionTypeEnum("shopping_occasion_type").default("normal"), 
  shoppingSpecialOccasionDescription: text("shopping_special_occasion_description"),

  // Para a subcategoria 'transportation'
  startPlaceId: integer("start_place_id"),
  endPlaceId: integer("end_place_id"),
  startingPoint: text("starting_point"),
  destination: text("destination"), 
  transportMode: transportModeEnum("transport_mode"),
  transportDescription: text("transport_description"),

  // Para a subcategoria 'health'
  healthTypeId: integer("health_type_id"),
  healthDescription: text("health_description"),

  // Para a subcategoria 'family'
  familyMemberId: integer("family_member_id"),
  familyDescription: text("family_description"),

  // Para a subcategoria 'charity'
  charityTypeId: integer("charity_type_id"),
  charityDescription: text("charity_description"),
  //-------------------------------------------------------------------------


  
  
  

  // Text fields
  description: text("description"),

  purchaseType: purchaseTypeEnum("purchase_type"),

  createdAt: timestamp("created_at").defaultNow().notNull(),
});



// RELAÇÕES

export const expensesRelations = relations(expenses, ({ one }) => ({
  occasionalGroup: one(occasionalGroups, {
    fields: [expenses.occasionalGroupId],
    references: [occasionalGroups.id],
  }),

  
  // RELAÇÕES
  //--------------------------------------------------------------------------
  // Define que cada despesa pode estar associada a um tipo de despesa fixa específico
  fixedExpenseType: one(fixedExpenseTypes, {
    fields: [expenses.fixedExpenseTypeId],
    references: [fixedExpenseTypes.id],
  }),

  // Define que cada despesa pode estar associada a um supermercado específico
  supermarket: one(supermarkets, {
    fields: [expenses.supermarketId],
    references: [supermarkets.id],
  }),

  // Define que cada despesa pode estar associada a um restaurante específico
  restaurant: one(restaurants, {
    fields: [expenses.restaurantId],
    references: [restaurants.id],
  }),

  // Define que cada despesa pode estar associada a um tipo de serviço específico
  serviceType: one(serviceTypes, {
    fields: [expenses.serviceTypeId],
    references: [serviceTypes.id],
  }),

  // Define que cada despesa pode estar associada a um tipo de lazer específico
  leisureType: one(leisureTypes, {
    fields: [expenses.leisureTypeId],
    references: [leisureTypes.id],
  }),

  // Define que cada despesa pode estar associada a um tipo de cuidado pessoal específico
  personalCareType: one(personalCareTypes, {
    fields: [expenses.personalCareTypeId],
    references: [personalCareTypes.id],
  }),

  // Define que cada despesa pode estar associada a uma loja específica
  shop: one(shops, { 
    fields: [expenses.shopId],
    references: [shops.id],
  }),

  // Define que cada despesa pode estar associada a um lugar específico
  startPlace: one(places, { 
    fields: [expenses.startPlaceId],
    references: [places.id],
    relationName: "start_place_relation", 
  }),
  endPlace: one(places, { 
    fields: [expenses.endPlaceId],
    references: [places.id],
    relationName: "end_place_relation",
  }),

  // Define que cada despesa pode estar associada a um tipo de demanda de saúde específico
  healthType: one(healthTypes, { 
    fields: [expenses.healthTypeId],
    references: [healthTypes.id],
  }),

  // Define que cada despesa pode estar associada a um membro da família específico
  familyMember: one(familyMembers, {
    fields: [expenses.familyMemberId],
    references: [familyMembers.id],
  }),

  // Define que cada despesa pode estar associada a um tipo de caridade específico
  charityType: one(charityTypes, {
    fields: [expenses.charityTypeId],
    references: [charityTypes.id],
  }),
  //--------------------------------------------------------------------------
  

  
 
  
}));

export const occasionalGroupsRelations = relations(
  occasionalGroups,
  ({ many }) => ({
    expenses: many(expenses),
  }),
);

//--------------------------------------------------------------------------
// Define que um tipo de despesa fixa pode ter várias despesas associadas
export const fixedExpenseTypesRelations = relations(fixedExpenseTypes, ({ many }) => ({ 
  expenses: many(expenses),
}));

// Define que um supermercado pode ter várias despesas associadas
export const supermarketsRelations = relations(supermarkets, ({ many }) => ({
  expenses: many(expenses),
}));

// Define que um restaurante pode ter várias despesas associadas
export const restaurantsRelations = relations(restaurants, ({ many }) => ({
  expenses: many(expenses),
}));

// Define que um tipo de serviço pode ter várias despesas associadas
export const serviceTypesRelations = relations(serviceTypes, ({ many }) => ({
  expenses: many(expenses),
}));

// Define que um tipo de lazer pode ter várias despesas associadas
export const leisureTypesRelations = relations(leisureTypes, ({ many }) => ({
  expenses: many(expenses),
}));

// Define que um tipo de cuidado pessoal pode ter várias despesas associadas
export const personalCareTypesRelations = relations(personalCareTypes, ({ many }) => ({
    expenses: many(expenses),
  }),
);

// Define que uma loja pode ter várias despesas associadas
export const shopsRelations = relations(shops, ({ many }) => ({ 
  expenses: many(expenses),
}));

// Define que um lugar pode ter várias despesas associadas
export const placesRelations = relations(places, ({ many }) => ({ 
  expensesStart: many(expenses, { relationName: "start_place_relation" }),
  expensesEnd: many(expenses, { relationName: "end_place_relation" }),
}));

// Define que um tipo de demanda de saúde pode ter várias despesas associadas
export const healthTypesRelations = relations(healthTypes, ({ many }) => ({ 
  expenses: many(expenses),
}));

// Define que um membro da família pode ter várias despesas associadas
export const familyMembersRelations = relations(familyMembers, ({ many }) => ({
  expenses: many(expenses),
}));

// Define que um tipo de caridade pode ter várias despesas associadas
export const charityTypesRelations = relations(charityTypes, ({ many }) => ({
  expenses: many(expenses),
}));
//--------------------------------------------------------------------------






// Insert Schemas (createInsertSchema): Utiliza o drizzle-zod para criar automaticamente esquemas de validação Zod para a inserção de dados em cada tabela.
// O .omit({ id: true, createdAt: true }) é usado para indicar que os campos id e createdAt (que são gerados automaticamente pelo banco de dados)
// não precisam ser fornecidos ao criar um novo registro.

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
});

export const insertOccasionalGroupSchema = createInsertSchema(
  occasionalGroups,
).omit({
  id: true,
  createdAt: true,
});

export const insertExpenseSchema = createInsertSchema(expenses)
  .omit({
    id: true,
    createdAt: true,
  })
  .extend({
    purchaseDate: z.string().transform((str) => new Date(str)),
  });

//--------------------------------------------------------------------------
// Define esquema de inserção para a tabela de tipos de despesas fixas
export const insertFixedExpenseTypeSchema = createInsertSchema(fixedExpenseTypes).omit({ 
  id: true,
});

// Define esquema de inserção para a tabela de supermercados
export const insertSupermarketSchema = createInsertSchema(supermarkets).omit({
  id: true,
});

// Define esquema de inserção para a tabela de restaurantes
export const insertRestaurantSchema = createInsertSchema(restaurants).omit({
  id: true,
});

// Define esquema de inserção para a tabela de tipos de serviços
export const insertServiceTypeSchema = createInsertSchema(serviceTypes).omit({
  id: true,
});

// Define esquema de inserção para a tabela de tipos de lazer
export const insertLeisureTypeSchema = createInsertSchema(leisureTypes).omit({
  id: true,
});

// Define esquema de inserção para a tabela de tipos de cuidados pessoais
export const insertPersonalCareTypeSchema = createInsertSchema(personalCareTypes).omit({
  id: true,
});

// Define esquema de inserção para a tabela de lojas
export const insertShopSchema = createInsertSchema(shops).omit({
  id: true,
});

// Define esquema de inserção para a tabela de lugares
export const insertPlaceSchema = createInsertSchema(places).omit({ 
  id: true,
});

// Define esquema de inserção para a tabela de tipos de saúde
export const insertHealthTypeSchema = createInsertSchema(healthTypes).omit({ 
  id: true,
});

// Define esquema de inserção para a tabela de membros da família
export const insertFamilyMemberSchema = createInsertSchema(familyMembers).omit({
  id: true,
});

// Define esquema de inserção para a tabela de tipos de caridade
export const insertCharityTypeSchema = createInsertSchema(charityTypes).omit({
  id: true,
});
//--------------------------------------------------------------------------



// TIPOS (export type): Exporta tipos TypeScript (InsertUser, User, InsertExpense, Expense, etc.) que são inferidos a partir dos esquemas Drizzle e Zod.
// Isso fornece forte tipagem em todo o seu aplicativo, ajudando a prevenir erros e melhorando a autocompletar no seu editor de código.
export type InsertUser = z.infer<typeof insertUserSchema>; // Para validação de inserção
export type User = typeof users.$inferSelect; // Para leitura da tabela

export type InsertOccasionalGroup = z.infer<typeof insertOccasionalGroupSchema>;
export type OccasionalGroup = typeof occasionalGroups.$inferSelect;

export type InsertExpense = z.infer<typeof insertExpenseSchema>;
export type Expense = typeof expenses.$inferSelect;

//--------------------------------------------------------------------------
// Define o tipo TypeScript para a inserção e leitura de tipos de despesas fixas
export type InsertFixedExpenseType = z.infer<typeof insertFixedExpenseTypeSchema>; 
export type FixedExpenseType = typeof fixedExpenseTypes.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de supermercados
export type InsertSupermarket = z.infer<typeof insertSupermarketSchema>;
export type Supermarket = typeof supermarkets.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de restaurantes
export type InsertRestaurant = z.infer<typeof insertRestaurantSchema>;
export type Restaurant = typeof restaurants.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de tipos de serviços
export type InsertServiceType = z.infer<typeof insertServiceTypeSchema>;
export type ServiceType = typeof serviceTypes.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de tipos de lazer
export type InsertLeisureType = z.infer<typeof insertLeisureTypeSchema>;
export type LeisureType = typeof leisureTypes.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de tipos de cuidados pessoais
export type InsertPersonalCareType = z.infer<typeof insertPersonalCareTypeSchema>;
export type PersonalCareType = typeof personalCareTypes.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de lojas
export type InsertShop = z.infer<typeof insertShopSchema>;
export type Shop = typeof shops.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de lugares
export type InsertPlace = z.infer<typeof insertPlaceSchema>;
export type Place = typeof places.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de tipos de saúde
export type InsertHealthType = z.infer<typeof insertHealthTypeSchema>;
export type HealthType = typeof healthTypes.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de membros da família
export type InsertFamilyMember = z.infer<typeof insertFamilyMemberSchema>;
export type FamilyMember = typeof familyMembers.$inferSelect;

// Define o tipo TypeScript para a inserção e leitura de tipos de caridade
export type InsertCharityType = z.infer<typeof insertCharityTypeSchema>;
export type CharityType = typeof charityTypes.$inferSelect;
//--------------------------------------------------------------------------
